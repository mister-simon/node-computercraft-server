os.loadAPI("movement")
os.loadAPI("lib")

-- Exposed variables
startCoords = {x = 0, y = 0, z = 0}
currentCoords = {x = 0, y = 0, z = 0}
startDirection = 1
currentDirection = 1
path = {axis = "z", distance = 0}

local forwardAction = movement.createHandlerFromMovement(turtle.forward)
local upAction = movement.createHandlerFromMovement(turtle.up)
local downAction = movement.createHandlerFromMovement(turtle.down)
-- TODO: Back?

-- Coordinates and Direction is relative to the turtle's start position
local directions = {1 = "North",  2 = "East", 3 = "South", 4 = "West"}
local axisFromDirectionDict = {1 = "z", 2 = "x", 3 = "z", 4 = "x"}
local directionsLength = #directions
local currentAxis = "z"
local currentPathIndex = 0



-- Private functions 
-- Params: Int
local function updateX(amount) 
	currentCoords.x = currentCoords.x + amount
end

-- Params: Int
local function updateY(amount) 
	currentCoords.y = currentCoords.y + amount
end

-- Params: Int
local function updateZ(amount) 
	currentCoords.z = currentCoords.z + amount
end

-- Params: String (x, y, z)
local function updatePath(axis)
	if currentAxis == axis then
		path[currentPathIndex].distance = path[currentPathIndex].distance + 1
	else
		currentAxis = axis
		currentPathIndex = currentPathIndex + 1
		path[currentPathIndex] = {axis= axis, distance = 0}
	end
end

-- Params: Int
local function updateStoredDirection(turnAmount)
		local newDirection = currentDirection + turnAmount
		
		if newDirection > directionsLength then
			newDirection = 1
		elseif newDirection < 1 then
			newDirection = directionsLength
		else
			 newDirection = newDirection
		end
		
		currentDirection = newDirection
		return newDirection
end

-- Params: Int, Handler Class
local function repeatMovement(distance, actionHandler)
	local distanceCovered = 0
	for i = 1, distance do
		actionHandler.run()
	end
	
	return distanceCovered
end

-- Params: Int, Function, Int (1, -1), Bool
local function repeatTurn(turnIterations, turnAction, direction, dumbTurn)
	-- If no dumbTurn (force turning the requested amount of times), calculate how many rotations are actually needed.
	if dumbTurn ~= true then
		turnIterations = turnIterations % directionsLength
	end

	for i = 1, turnIterations do
		turnAction()
	end
	
	updateStoredDirection((turnIterations * direction) % directionsLength)
end

-- Params: Int, Int (1, -1)
local function moveOnVerticalAxis(distance, verticalDirection)
	local distanceCovered = repeatMovement(distance, upAction)
	updatePath("y", distanceCovered)
	updateY(distanceCovered * verticalDirection)
end



-- Exposed API / Functions
-- Params: Int
function forward(distance)
	local distanceCovered = repeatMovement(distance, forwardAction)
	updatePath(axisFromDirectionDict[updateStoredDirection(direction)], distanceCovered)
	
	if currentAxis == "z" then
		updateZ(distanceCovered)
	else
		updateX(distanceCovered)
	end
	
end

-- Params: Int
function up(distance)
	moveOnVerticalAxis(distance, 1)
end

-- Params: Int
function down(distance)
	moveOnVerticalAxis(distance, -1)
end

-- Params: Int, Bool
function turnLeft(turnIterations, dumbTurn)
	repeatTurn(turnIterations, turtle.turnLeft, -1, dumbTurn)
end

-- Params: Int, Bool
function turnRight(turnIterations, dumbTurn)
	repeatTurn(turnIterations, turtle.turnRight, 1, dumbTurn)
end